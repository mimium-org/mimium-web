---
title: Changes in V3
date: 2025-10-07
draft: false
bookHidden: false
---

# Language Spec Changes in mimium v3

mimium v3 represents a significant evolution of the language, introducing powerful new features that enhance expressiveness and usability while maintaining the core philosophy of audio-first programming. The major changes include record types with functional update syntax, parameter packs for flexible function calls, multi-stage computation (hygienic macros), and live coding support.

## Non-Breaking Changes (New Features)

### Record Type and Syntax

#### Basic Record Types (#99, #128)

mimium v3 introduces record types (similar to structs in other languages) with a syntax inspired by Elm. Records allow you to group related data together with named fields, making code more readable and maintainable.

**Basic Syntax:**

```rust
// Record literal with named fields
let myadsr_param = { 
   attack = 100.0,
   decay = 200.0,
   sustain = 0.6,
   release = 2000.0,
}

// Type annotations are optional
let myrecord = {
  freq:float = 440.0,
  amp = 0.5,
}

// Single-field records require trailing comma
let singlerecord = {
  value = 100,
}
```

**Accessing Record Fields:**

```rust
// Dot operator for field access
let attack_time = myadsr_param.attack

// Pattern matching in let bindings
let {attack, decay, sustain, release} = myadsr_param

// With partial application using underscore
let myattack = myadsr_param |> _.attack
```

**Record Update Syntax (#158):**

Creating modified versions of records is a common pattern in functional programming. mimium v3 introduces a clean syntax for updating records:

```rust
let myadsr = { attack = 0.0, decay = 10.0, sustain = 0.7, release = 10.0 }

// Update specific fields while keeping others unchanged
let newadsr = { myadsr <- attack = 4000.0, decay = 2000.0 }
// newadsr is { attack = 4000.0, decay = 10.0, sustain = 0.7, release = 10.0 }

// Original record remains unchanged (immutable semantics)
// myadsr is still { attack = 0.0, decay = 10.0, sustain = 0.7, release = 10.0 }
```

The record update syntax is implemented as syntactic sugar and ensures functional programming semantics - creating new records rather than modifying existing ones.

### Parameter Pack and Default Parameters

#### Parameter Pack (#130)

Parameter packs allow functions to accept tuples or records as arguments, automatically unpacking them into individual parameters. This feature greatly improves the usability of functions with multiple parameters.

**With Tuples:**

```rust
fn add(a:float, b:float)->float {
  a + b
}

// Direct call with individual arguments
add(100, 200)  // Returns 300

// Automatic unpacking of tuples
add((100, 200))  // Returns 300

// Works seamlessly with pipe operators
(100, 200) |> add  // Returns 300
```

**With Records:**

```rust
fn adsr(attack:float, decay:float, sustain:float, release:float)->float {
  // ADSR envelope implementation...
}

// Call with a record - fields can be in any order
let params = { attack = 100, decay = 200, sustain = 0.7, release = 1000 }
adsr(params)

// Or inline
adsr({ decay = 200, attack = 100, release = 1000, sustain = 0.7 })
```

This feature is particularly useful for audio processing functions that often have many parameters, allowing you to organize parameters as records for better clarity.

#### Default Parameters (#134)

Functions can now specify default values for parameters, reducing boilerplate when calling functions with common configurations:

```rust
fn foo(x = 100, y = 200) {
  x + y + 1
}

fn bar(x = 100, y) {
  x + y
}

fn dsp() {
  // Use empty record {} to accept all defaults
  foo({}) +           // Uses x=100, y=200, returns 301
  bar({y = 300})      // Uses x=100, y=300, returns 400
  // Total: 701
}
```

**Key Points:**
- Default values work with parameter pack syntax
- Use `{}` to accept all default values
- Specify only the parameters you want to override
- Currently works for direct function calls (non-closure contexts)

### Multi-Stage Computation (Hygienic Macro/Compile-time Computation) (#135)

One of the most powerful additions to mimium v3 is multi-stage computation, inspired by MetaOCaml and Scala 3. This allows you to write macros that generate code at compile-time while maintaining type safety and hygiene.

#### Motivation

Audio processing often involves two distinct phases:
1. Building the computation graph (structure)
2. Running the computation graph (processing samples)

Previously, parametric audio graphs required cumbersome higher-order functions. Multi-stage computation makes this more natural and efficient.

#### Basic Syntax

Two primitives enable multi-stage computation:

- **Quote** (`` `expr ``): Marks an expression for evaluation in the next stage
- **Splice** (`$expr`): Evaluates and inserts an expression from the previous stage
- **Macro expansion syntax** (`f!(args)`): Syntactic sugar for `${f(args)}`

**Example - Parametric Filter Bank:**

```rust
fn bandpass(x, freq) {
  // bandpass filter implementation...
}

fn filterbank(n, filter:(float,float)->float) -> `(float,float)->float {
  if (n > 0) {
    `{ |x,freq| 
       filter(x, freq + n*100) + filterbank!(n-1, filter)(x, freq)
    }
  } else {
    `{ |x,freq| 0 }
  }
}

fn dsp() {
  filterbank!(3, bandpass)(input, 1000)
  // This generates an unrolled filterbank at compile-time
}
```

**Example - Power Function Generator:**

```rust
#stage(macro)
fn genpower(n:float) -> `(float)->float {
    letrec aux = |n:float, x| {
        if (n > 1) {
            `{ $x * $(aux(n-1, x)) }
        } else {
            x
        }
    }
    `{ |x:float| $(aux(n, `x)) }
}

#stage(main)
fn dsp() {
   genpower!(3)(2.0)  // Compiles to 2.0 * 2.0 * 2.0 = 8.0
}
```

#### Global Stage Declaration Syntax (#154)

To avoid deeply nested brackets, mimium v3 introduces global-level stage declarations:

```rust
#stage(macro)
// Everything here is evaluated at compile-time (Stage 0)
fn mymacro(n:float) -> `float {
  `{ $n * 2.0 }
}
let compile_time_constant = 42

#stage(main)
// Everything here is evaluated at runtime (Stage 1)
fn dsp() {
  mymacro!(21)  // Results in 42.0
}
```

**Key Benefits:**
- Clear separation between compile-time and runtime code
- Less nesting than expression-level quotes
- Better organization for complex macro systems
- Type-checked macro expansion

### Live State Updating (#159)

mimium v3 introduces a groundbreaking live coding feature that allows you to modify code while it's running without interrupting audio playback.

#### How It Works

When you save a modified mimium file:

1. The compiler recompiles the code in the background
2. The new VM is compared with the running VM
3. Internal state (delays, feedback, etc.) is intelligently transferred
4. The audio thread seamlessly switches to the new code

**Key Advantages:**

- **No audio interruption**: Delay tails and reverb continue naturally
- **Smart state transfer**: Only the changed parts are updated
- **Preserves feedback loops**: Self-oscillating systems continue oscillating
- **Enables true live coding**: Modify parameters and structure in real-time

**Example Use Case:**

```rust
// Initial code
fn dsp() {
  let freq = 440.0
  sin(phasor(freq) * 3.14159 * 2.0)
}

// You can change the frequency while running:
fn dsp() {
  let freq = 880.0  // Just edit and save - no restart needed!
  sin(phasor(freq) * 3.14159 * 2.0)
}
```

Even more complex changes work:
- Adding new oscillators
- Changing filter parameters
- Modifying delay times
- Restructuring the audio graph

**Technical Details:**

- Implements a `state_tree` crate for state management
- Uses static memory allocation for deterministic state location
- Detects insertions, deletions, and replacements in the call tree
- Minimal data copying for maximum efficiency

**Current Limitations:**

- External I/O state (like GUI sliders) is reset on recompilation
- Future versions will support persistent external state

### Language Server (#151)

mimium v3 includes a new Language Server Protocol (LSP) implementation, providing IDE features for better developer experience.

**Features:**

- **Semantic highlighting**: Proper syntax highlighting based on the compiler's tokenizer
- **Error diagnostics**: Real-time error checking and reporting as you type
- **VSCode integration**: Works with the mimium VSCode extension v2.3+

**Implementation Details:**

- Built on `tower-lsp` framework
- Reuses mimium's existing compiler infrastructure
- Provides foundation for future features like auto-completion and go-to-definition

### GUI and Tooling Improvements

#### Slider UI (#147)

A new `Slider!` macro provides easy-to-use GUI controls for audio parameters:

```rust
fn dsp() {
    let gain = Slider!("gain", 0.5, 0.0, 1.0)  // name, default, min, max
    let freq = Slider!("frequency", 440.0, 20.0, 20000.0)
    
    sin(phasor(freq) * 3.14159 * 2.0) * gain
}
```

The slider values are available in real-time and can be adjusted while the audio is running.

#### Code Formatter (#143)

An experimental code formatter (`mimium-fmt`) has been added:

```bash
mimium-fmt myfile.mmm
```

**Features:**
- Consistent code formatting based on AST
- Uses the `pretty` crate for layout
- Integrated with updated parser (chumsky v0.10.x)

**Current Limitations:**
- Comments are removed during formatting (trivia not preserved in AST yet)
- Consider this experimental for now

## Breaking Changes

### Audio File Loading: `gen_sampler_mono` â†’ `Sampler_mono!` (#161)

The runtime `gen_sampler_mono` function has been replaced with a compile-time `Sampler_mono!` macro.

**Old Syntax:**

```rust
let mysampler = gen_sampler_mono("audio_file.wav")
fn dsp() {
  mysampler(phase)
}
```

**New Syntax:**

```rust
fn dsp() {
  let phase = phasor(1.0)
  Sampler_mono!("audio_file.wav")(phase)
}
```

**Benefits:**
- Audio files are loaded at compile-time
- Data is embedded directly in VM's data section
- Better performance (no runtime file I/O)
- Automatic caching and resource management
- Files are cached and reused across recompilations

### Probe Function: `make_probe` â†’ `Probe!` (#156)

The `make_probe` function has been replaced with the `Probe!` macro for consistency with other GUI features.

**Old Syntax:**

```rust
let myprobe = make_probe("test")
fn dsp() {
    osc(440) |> myprobe
}
```

**New Syntax:**

```rust
fn dsp() {
   osc(440) |> Probe!("test")
}
```

Both changes align with mimium v3's philosophy of using multi-stage computation to move more work to compile-time, resulting in better performance and cleaner syntax.

## Summary

mimium v3 brings significant improvements to the language:

- **Record types** provide better data organization
- **Parameter packs** make functions more flexible and easier to use
- **Multi-stage computation** enables powerful compile-time metaprogramming
- **Live state updating** enables true live coding without audio interruption
- **Language server** improves the development experience
- **Improved tooling** with GUI macros and formatting

These features work together to make mimium more expressive, efficient, and enjoyable to use for audio programming while maintaining backward compatibility for most existing code.

