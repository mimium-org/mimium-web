---
title: V3での変更
date: 2025-10-07
draft: false
bookHidden: false
---

# mimium v3における言語仕様の変更

mimium v3は言語の大きな進化を表しており、オーディオファーストプログラミングの中心的な哲学を維持しながら、表現力と使いやすさを向上させる強力な新機能を導入しています。主な変更点には、関数型の更新構文を持つレコード型、柔軟な関数呼び出しのためのパラメータパック、マルチステージ計算（ハイジェニックマクロ）、ライブコーディングサポートが含まれます。

## 非破壊的な変更（新機能）

### レコード型と構文

#### 基本的なレコード型 (#99, #128)

mimium v3では、Elmに着想を得た構文を持つレコード型（他言語の構造体に相当）を導入しています。レコードを使うことで、名前付きフィールドで関連するデータをグループ化でき、コードの可読性と保守性が向上します。

**基本構文:**

```rust
// 名前付きフィールドを持つレコードリテラル
let myadsr_param = { 
   attack = 100.0,
   decay = 200.0,
   sustain = 0.6,
   release = 2000.0,
}

// 型注釈はオプション
let myrecord = {
  freq:float = 440.0,
  amp = 0.5,
}

// 単一フィールドのレコードには末尾のカンマが必要
let singlerecord = {
  value = 100,
}
```

**レコードフィールドへのアクセス:**

```rust
// ドット演算子によるフィールドアクセス
let attack_time = myadsr_param.attack

// let束縛でのパターンマッチング
let {attack, decay, sustain, release} = myadsr_param

// アンダースコアを使った部分適用と組み合わせ
let myattack = myadsr_param |> _.attack
```

**レコード更新構文 (#158):**

レコードの変更版を作成することは関数型プログラミングでは一般的なパターンです。mimium v3では、レコードを更新するためのクリーンな構文を導入しています：

```rust
let myadsr = { attack = 0.0, decay = 10.0, sustain = 0.7, release = 10.0 }

// 特定のフィールドを更新し、他は変更しない
let newadsr = { myadsr <- attack = 4000.0, decay = 2000.0 }
// newadsr は { attack = 4000.0, decay = 10.0, sustain = 0.7, release = 10.0 }

// 元のレコードは変更されない（イミュータブルなセマンティクス）
// myadsr はまだ { attack = 0.0, decay = 10.0, sustain = 0.7, release = 10.0 }
```

レコード更新構文はシンタックスシュガーとして実装されており、関数型プログラミングのセマンティクスを保証します。既存のものを変更するのではなく、新しいレコードを作成します。

### パラメータパックとデフォルト引数

#### パラメータパック (#130)

パラメータパックを使うと、関数がタプルやレコードを引数として受け取り、自動的に個別のパラメータにアンパックできます。この機能は、複数のパラメータを持つ関数の使いやすさを大幅に向上させます。

**タプルの場合:**

```rust
fn add(a:float, b:float)->float {
  a + b
}

// 個別の引数での直接呼び出し
add(100, 200)  // 300を返す

// タプルの自動アンパック
add((100, 200))  // 300を返す

// パイプ演算子とシームレスに連携
(100, 200) |> add  // 300を返す
```

**レコードの場合:**

```rust
fn adsr(attack:float, decay:float, sustain:float, release:float)->float {
  // ADSRエンベロープの実装...
}

// レコードで呼び出し - フィールドの順序は任意
let params = { attack = 100, decay = 200, sustain = 0.7, release = 1000 }
adsr(params)

// またはインライン
adsr({ decay = 200, attack = 100, release = 1000, sustain = 0.7 })
```

この機能は、多くのパラメータを持つことが多いオーディオ処理関数で特に有用であり、明確性のためにパラメータをレコードとして整理できます。

#### デフォルト引数 (#134)

関数でパラメータのデフォルト値を指定できるようになり、一般的な設定で関数を呼び出す際のボイラープレートが減少します：

```rust
fn foo(x = 100, y = 200) {
  x + y + 1
}

fn bar(x = 100, y) {
  x + y
}

fn dsp() {
  // 空のレコード{}を使ってすべてのデフォルトを受け入れる
  foo({}) +           // x=100, y=200を使用、301を返す
  bar({y = 300})      // x=100, y=300を使用、400を返す
  // 合計: 701
}
```

デフォルト値はパラメータパック構文と連携します。`{}`を使ってすべてのデフォルト値を受け入れ、上書きしたいパラメータのみを指定できます。現在、これは直接的な関数呼び出し（非クロージャコンテキスト）で動作します。

### マルチステージ計算（ハイジェニックマクロ/コンパイル時計算） (#135)

mimium v3の最も強力な追加機能の1つは、MetaOCamlとScala 3に着想を得たマルチステージ計算です。これにより、型安全性とハイジーンを維持しながら、コンパイル時にコードを生成するマクロを書くことができます。

#### 動機

オーディオ処理には、しばしば2つの異なるフェーズが含まれます：
1. 計算グラフの構築（構造）
2. 計算グラフの実行（サンプル処理）

以前は、パラメトリックなオーディオグラフには煩雑な高階関数が必要でした。マルチステージ計算により、これをより自然で効率的に記述できます。

#### 基本構文

2つのプリミティブがマルチステージ計算を可能にします。**クォート** (`` `expr ``) は次のステージで評価される式をマークします。**スプライス** (`$expr`) は前のステージから式を評価して挿入します。**マクロ展開構文** (`f!(args)`) は `${f(args)}` のシンタックスシュガーを提供します。

**例 - パラメトリックなフィルターバンク:**

```rust
fn bandpass(x, freq) {
  // バンドパスフィルタの実装...
}

fn filterbank(n, filter:(float,float)->float) -> `(float,float)->float {
  if (n > 0) {
    `{ |x,freq| 
       filter(x, freq + n*100) + filterbank!(n-1, filter)(x, freq)
    }
  } else {
    `{ |x,freq| 0 }
  }
}

fn dsp() {
  filterbank!(3, bandpass)(input, 1000)
  // コンパイル時に展開されたフィルターバンクを生成
}
```

**例 - べき乗関数ジェネレータ:**

```rust
#stage(macro)
fn genpower(n:float) -> `(float)->float {
    letrec aux = |n:float, x| {
        if (n > 1) {
            `{ $x * $(aux(n-1, x)) }
        } else {
            x
        }
    }
    `{ |x:float| $(aux(n, `x)) }
}

#stage(main)
fn dsp() {
   genpower!(3)(2.0)  // 2.0 * 2.0 * 2.0 = 8.0にコンパイル
}
```

#### グローバルステージ宣言構文 (#154)

深くネストされた括弧を避けるため、mimium v3ではグローバルレベルのステージ宣言を導入しています：

```rust
#stage(macro)
// ここのすべてはコンパイル時（ステージ0）で評価される
fn mymacro(n:float) -> `float {
  `{ $n * 2.0 }
}
let compile_time_constant = 42

#stage(main)
// ここのすべては実行時（ステージ1）で評価される
fn dsp() {
  mymacro!(21)  // 結果は42.0
}
```

このアプローチは、式レベルのクォートよりも少ないネストでコンパイル時とランタイムコードの明確な分離を提供します。型チェックされたマクロ展開を維持しながら、複雑なマクロシステムのより良い整理を可能にします。

### ライブステート更新 (#159)

mimium v3では、オーディオ再生を中断することなく実行中にコードを変更できる画期的なライブコーディング機能を導入しています。

#### 仕組み

変更されたmimiumファイルを保存すると：

1. コンパイラがバックグラウンドでコードを再コンパイル
2. 新しいVMが実行中のVMと比較される
3. 内部状態（ディレイ、フィードバックなど）がインテリジェントに転送される
4. オーディオスレッドが新しいコードにシームレスに切り替わる

このシステムはいくつかの主要な利点を提供します。オーディオの中断がなく、ディレイテールやリバーブが自然に続きます。スマートな状態転送は変更された部分のみを更新し、フィードバックループを保持するため、自己発振システムが発振し続けます。これにより、パラメータと構造をリアルタイムで変更できる真のライブコーディングが可能になります。

**使用例:**

```rust
// 初期コード
fn dsp() {
  let freq = 440.0
  sin(phasor(freq) * 3.14159 * 2.0)
}

// 実行中に周波数を変更できる:
fn dsp() {
  let freq = 880.0  // 編集して保存するだけ - 再起動不要！
  sin(phasor(freq) * 3.14159 * 2.0)
}
```

新しいオシレータの追加、フィルタパラメータの変更、ディレイタイムの変更、オーディオグラフの再構築など、さらに複雑な変更も機能します。

実装は、決定論的な状態位置のための静的メモリ割り当てを持つ状態管理用の`state_tree`クレートを使用します。最大効率のための最小限のデータコピーで、コールツリー内の挿入、削除、置換を検出します。

現在、外部I/O状態（GUIスライダーなど）は再コンパイル時にリセットされます。将来のバージョンでは永続的な外部状態をサポートする予定です。

### 言語サーバー (#151)

mimium v3には、より良い開発者体験のためのIDE機能を提供する新しい言語サーバープロトコル（LSP）実装が含まれています。

言語サーバーは、コンパイラのトークナイザに基づく適切なシンタックスハイライトでセマンティックハイライトを提供します。タイピング中のリアルタイムエラーチェックとレポートのためのエラー診断が含まれています。VSCode統合はmimium VSCode拡張v2.3+で動作します。

実装は`tower-lsp`フレームワーク上に構築され、mimiumの既存のコンパイラインフラストラクチャを再利用します。オートコンプリートやgo-to-definitionなどの将来の機能の基盤を提供します。

### GUIとツーリングの改善

#### スライダーUI (#147)

新しい`Slider!`マクロは、オーディオパラメータ用の使いやすいGUIコントロールを提供します：

```rust
fn dsp() {
    let gain = Slider!("gain", 0.5, 0.0, 1.0)  // 名前、デフォルト、最小、最大
    let freq = Slider!("frequency", 440.0, 20.0, 20000.0)
    
    sin(phasor(freq) * 3.14159 * 2.0) * gain
}
```

スライダーの値はリアルタイムで利用可能であり、オーディオの実行中に調整できます。

#### コードフォーマッター (#143)

実験的なコードフォーマッター（`mimium-fmt`）が追加されました：

```bash
mimium-fmt myfile.mmm
```

フォーマッターはAST基づく一貫したコードフォーマットを提供し、レイアウトに`pretty`クレートを使用します。更新されたパーサー（chumsky v0.10.x）と統合されています。ただし、triviaがまだASTに保存されていないため、フォーマット中にコメントが削除されます。したがって、これは現時点では実験的と考えてください。

## 破壊的変更

### オーディオファイル読み込み: `gen_sampler_mono` → `Sampler_mono!` (#161)

ランタイムの`gen_sampler_mono`関数がコンパイル時の`Sampler_mono!`マクロに置き換えられました。

**旧構文:**

```rust
let mysampler = gen_sampler_mono("audio_file.wav")
fn dsp() {
  mysampler(phase)
}
```

**新構文:**

```rust
fn dsp() {
  let phase = phasor(1.0)
  Sampler_mono!("audio_file.wav")(phase)
}
```

オーディオファイルはコンパイル時にロードされ、VMのデータセクションに直接埋め込まれ、ランタイムファイルI/Oなしで優れたパフォーマンスを提供します。システムには自動キャッシングとリソース管理が含まれており、ファイルは再コンパイル間でキャッシュされ再利用されます。

### プローブ関数: `make_probe` → `Probe!` (#156)

`make_probe`関数は、他のGUI機能との一貫性のために`Probe!`マクロに置き換えられました。

**旧構文:**

```rust
let myprobe = make_probe("test")
fn dsp() {
    osc(440) |> myprobe
}
```

**新構文:**

```rust
fn dsp() {
   osc(440) |> Probe!("test")
}
```

両方の変更は、より多くの作業をコンパイル時に移すためにマルチステージ計算を使用するというmimium v3の哲学に沿っており、より良いパフォーマンスとクリーンな構文をもたらします。

## まとめ

mimium v3は言語に大きな改善をもたらします。レコード型はより良いデータ整理を提供し、パラメータパックは関数をより柔軟で使いやすくします。マルチステージ計算は強力なコンパイル時メタプログラミングを可能にし、ライブステート更新はオーディオ中断のない真のライブコーディングを可能にします。言語サーバーは開発体験を改善し、GUIマクロやフォーマットを備えた改善されたツーリングは生産性を向上させます。これらの機能は協調して動作し、mimiumをオーディオプログラミングにおいてより表現力豊かで、効率的で、楽しく使用できるものにします。既存のコードとの後方互換性も維持されています。
