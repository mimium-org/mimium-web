---
title: 基本言語仕様
date: 2021-01-16T10:57:29.049Z
weight: 1
description: mimium言語の言語仕様に関する項目です。
draft: false
bookHidden: false
mermaid: true
---

# mimiumの言語仕様

このページでは、mimium言語の基本的文法(シンタックスおよびセマンティクス)について説明します。

## コメントアウト

Rust、C++やJavaScriptと同様、行中の`//`より右側はコメントとして扱われます。
また`/*  */`のように囲むと、複数行をまとめてコメントアウトできます。

## 変数宣言、代入

`let`キーワードに続けて名前、`=`、代入したい値を記述すると、変数が作られます。

```rust
let mynumber = 1000
```

すでにスコープ中に同名の変数があった場合、そのスコープ内で一番新しく`let`宣言された変数が参照されます。（元々の変数に対しては影響を与えません。）これは、**シャドーイング**と呼ばれます。

```rust
fn dsp(x){
  let x = 1.0
  x //x is always 1.0 whatever argument is given
}
```

`let`なしで変数を代入すると、すでに宣言されている変数に新たに値を代入します。

```rust
let mynumber = 1000
mynumber = 2000 // 2000 is newly assigned to mynumber
```


> [!NOTE]
> mimiumでletで作成される変数は原則的にミュータブル（常に破壊的代入が可能）です。ただし、mimiumの関数評価は**値呼び**という戦略に基づいているので、例えば関数の引数に対して破壊的代入を行っても関数の外側に影響を与えることはありません。また、mimiumにはforループのような命令型の構文が存在しないため、実際は破壊的代入を積極的に使用する意味がそこまでありません。
> 
> ただし、クロージャによってキャプチャされた変数が関数の外側に飛び出すことによって、限定的に共有された値への読み書きを行うことができます。（これがどういう意味なのかよくわからないうちは、変数への再代入は特に意味なしというぐらいに考えても大丈夫です。）

## 型

**型**とは変数などのデータを数値や文字列など目的に応じて区別するための概念です。
mimiumは**静的型付け**言語と呼ばれる、コンパイル時に（音を実際に鳴らす前）すべての型が決定される言語です。

静的型付け言語は一般的に、実行中に型をチェックする言語よりも実行速度の面で有利です。その一方、型の指定を手動で行う場合は記述が長くなりがちというデメリットも存在しますが、mimiumでは**型推論**と呼ばれる、文脈から型が自動的に決定できる場合は型注釈を省略できる機能が存在しているので、コードを簡潔に保つことが可能です。

型にはそれ以上分解できない最小単位であるプリミティブ型と、複数の型を組み合わせて作る合成型（aggregate type）が存在します。

型の明示的な注釈は変数の宣言と関数の宣言時に可能です。
変数および関数のパラメータでは名前に続けて`:`（コロン）を挟み型名を書くことで指定可能です。

```rust
let myvar:float = 100
```
以下のように異なる型へ代入した場合はコンパイル時にエラーが発生します。
```rust
let myvar:string = 100
```

関数での型宣言では返り値をパラメータの括弧に続けて`->`を挟んで書くことで指定できます。

```rust
fn add(x:float,y:float)->float{
  x + y
}
```
このadd関数の場合、文脈からxとyがfloatであることを予測できる[^binaryop]ので以下のように省略できます。

```rust
fn add(x,y){
  x+y
}
```

[^binaryop]: mimiumでは`+`や`*`などの算術演算子を数値型にしか使えないため。今後変更になる可能性もあります。

### プリミティブ型

mimiumにおけるプリミティブ型は`float`と`string`、`void`のみです。

mimiumでは数値型は`float`（内部的には64bit float）のみとなっています。
整数を利用するには`round`、`ceil`、`floor`関数などを利用します。

`string`型の値は`"hoge"`のようにダブルクオーテーションで囲った文字列リテラルから生成できます。
現在は文字列の切り出しや結合には対応しておらず、用途は基本的には

1. `make_probe`関数に渡してデバッグ用途に使う
2. `make_sampler`関数に渡してオーディオファイルを読み込む
3. `include`に渡して他のソースファイルを読み込む

のいずれかに限られています。

`void`は値を持たない型で、関数の返り値が存在しないことを明示するのに使用します。

### 合成型

### 関数型

関数型は`(T1,T2,...)->T`のようなシグネチャで表記します。

#### 配列

*mimium v2 では配列の実装は現在検討中になっています。*

<!-- 配列は、同じ型の値を複数個連続して格納できる型です。`[]`（アングルブラケット）で囲んだカンマ区切りの値で生成できます。

```rust
myarr = [1,2,3,4,5,6,7,8,9,10]
```

配列型の値に`myarr[0]`のようにアングルブラケットで0基準のインデックスを指定することで配列の値を取り出すことができます。

```
arr_content = myarr[0] //arr_content should be 1
```
また左辺値に同様にアングルブラケットを使うことで配列の中身を書き換えることができます。

```
myarr[4] = 20 //myarr becomes [1,2,3,4,20,6,7,8,9,10]
```

**配列のサイズは固定です。配列の後ろに値を追加していくような操作はできません。また境界チェックもないため範囲外へのアクセスはクラッシュを引き起こします。** 

##### 自動内挿

インデックスは小数点以下の値でアクセスされた場合、自動で線形補完されて出力されます。

```
arr_content = myarr[1.5] //should be 2.5
```
自動で整数に丸められることはないので内挿を避けたい場合は`round`関数などでインデックスを丸める必要があります。

-->

#### タプル

タプルは、異なる型を1つにまとめた値です。変数を`()`（丸括弧）で囲んでカンマ区切りの変数を入れることで生成できます。
タプルは配列とも似ていますが、各要素で異なる型を持つことができます。

```rust
let mytup = (100,200,300)
```

左辺値にカンマ区切りの変数を置くことでタプルの値を取り出すことができます。

```rust
let (one,two,three) = mytup
```

この場合、型を明示するときは各要素にコロンをつけるのではなく、パターン全体からコロンに続けて方を表示する必要があります。

左辺値にカンマ区切りの変数を置くことでタプルの値を取り出すことができます。

```rust
let (one,two,three):(float,float,float) = mytup
```

> [!NOTE]
> 
> *今後、左辺値で分解するだけではなく、`mytup.1`のようにインデックスで取り出す記法も実装される予定です。*


タプルはmimiumの中では典型的に信号処理でステレオやマルチチャンネルなどのオーディオ信号のチャンネルをまとめて扱うために利用されています。


#### 型エイリアス

*型エイリアスはmimium v2では現在実装中です。*

<!-- タプルは型注釈が長いので、以下のような構文でエイリアスを作ることができます。

```rust
type FilterCoeffs = (float,float,float,float,float)
``` -->

#### 構造体（レコード型）

*レコード型はmimium v2では現在実装中です。詳しくはこちらのプロポーザルを参照。* https://github.com/tomoyanonymous/mimium-rs/issues/99 


<!-- 構造体は、タプルと同じ機能を持ちますがフィールド名を持たせることが可能です。
構造体型の変数には`変数.フィールド名`のようにドット演算子でアクセスすることができます。


**構造体は無名型が作れません。** 先に型エイリアスを宣言してから`型名{変数1,変数2...}`という構文で初期化して使用する形になります。

```rust
type MyBigStruct = {"field1":float,"field2":FilterCoeffs,"field3":string}

mystr = MyBigStruct{100,(0.0,1.0,1.2,0.8,0.4),"test"}

println(mystr.field1)
printlnstr(mystr.field3)
```

> [!NOTE]
> `mystr.fst = 111`のように構造体へ再代入する構文は現在実装中です。 -->

## 関数

関数は、複数の値を取って新しい値を返すような、再利用可能な手続きをまとめたものです。

例として2つの値を足算して返すだけのadd関数を考えます。

```rust
fn add(x,y){
  x+y
}
```

mimiumでは関数が**第一級**の値として扱えます。これは、関数を変数に代入したり、関数を引数として受け取ったりできるということです。

たとえば、先ほどのadd関数の型注釈は`(float,float)->float`のようになっています。先ほどのadd関数を変数に代入する場合は以下のように書けます。関数を関数のパラメータとして代入する場合は高階関数の項を参照してください。

```rust
let my_function:(float,float)->float = add
```
### 無名関数（ラムダ式）

実は先ほどの関数宣言は以下のような、無名関数を変数に格納する構文へのエイリアスです。

```rust
let add = |x:float,y:float|->float {x+y}
```
このような関数を変数に代入しないまま直接呼び出すことも可能です。

```rust
println(|x,y|{x + y}(1,2)) //print "3"
```

### パイプ（`|>`）演算子

mimiumではパイプ演算子`|>`利用することで`a(b(c(d)))`のようにネストした関数呼び出しを`d |> c |> b |> a`のように書き換えることができます。

パイプ演算子は他のどの演算子よりも低い結合順序を持っています。また、パイプの前後で改行が許されます。次の部分適用と組み合わせることで、データフローをわかりやすく表すことができます。

> [!NOTE]
> *現在パイプ演算子はパラメータが1つの関数でのみ使用可能です。今後パラメータパックなどの機能でタプル型の値を自動展開することでパラメータが2つ以上の関数でも利用できるようになる予定です.*

### アンダースコア(`_`)による部分適用

関数適用の引数にアンダースコア(`_`)を使用すると、その部分を新たな引数とした関数を作れます。例えば足し算のadd関数の、片方の引数を1で固定した新たな関数addoneを作るとしましょう。

```rust
let addone = add(_,1)
```

これはコンパイラによる特別なマクロ展開のような実装（シンタックスシュガー）で、以下の構文と同等です。

```rust
let addone =　|lambda_a1| add(lambda_a1,1)
```

パイプ演算子と組み合わせると、次のような形でデータフローを表せます。

```rust
fn foo(x, y, z) {
    100.0 * x + 10.0 * y + z
}
let d2 = _ / _
let f = foo(1.0, _, 3.0)
fn dsp(){
    let x = 3.0 |>
        1.0 + _ |>
        d2(_, 2.0) |>
        f
    let y = 3.0
        |> 1.0 + _
        |> |arg| d2(arg, 2.0)
        |> f

    (x, y)
}
```

パイプ演算子は直前、直後での改行が許されています。

### 再帰によるループ

名前のついている関数は自分自身を呼び出すことも可能です。

階乗を計算するfact関数は以下のように定義できます。

```rust
fn fact(input:float){
  if(input>0) 1 else input * fact(input-1)
}
```

再帰関数は無限ループを発生させる可能性があるので注意して使用してください。

### `letrec`

再帰関数はトップレベルでの関数定義のみで許され、`let`とラムダ式では表現することができません。ネストされた関数定義の中で再帰関数を定義したい場合、`let`の代わりに`letrec`を使用することで再帰関数を定義できます。

```rust
letrec fact = |input|{
  if(input>0) 1 else input * fact(input-1)
}
```

これは`fn`の構文と内部的に完全に等価です。注意点として、`letrec`で宣言する変数では`let`のようにタプルを分解するようなパターンは受け取れません。


### クロージャ

TBD

## 式（expression）、文（statement）、ブロック

関数などで使われていた中括弧`{}`で囲まれた**文**の集まりは**ブロック**と呼ばれる単位です。**文（statement）**はほとんどの場合`let a = b`,`x = y`のような**式**の代入をする構文で構成されています。**式（expression）** は`1000`のような数字、`mynumber`のような変数シンボル、`1+2*3`のような演算式、`add(x,y)`のような返り値を持つ関数呼び出しなどで構成される単位です。

**ブロック**は実は**式**の1つです。
ブロックには複数の文を置くことができ、最後の1行の式を返り値として持ちます。

```rust
//mynumber should be 6
let mynumber = {
  let x = 2
  let y = 4
  x+y
}
```

## 条件分岐

mimiumの条件分岐は`if (condition) then_expression else else_expression`という構文を持っています。

`condition`、`then_expression`、`else_expression`はすべて式です。
conditionの値が0より大きい時`then_expression`部分が、そうでなければ`else_expression`が評価されます。

then/elseの部分をブロックとして表現すれば、以下のようにできます。

```rust
fn fact(input:float){
  if(input>0){
    1
  }else{
    input * fact(input-1)
  }
}
```
一方でif文自体も式として扱えるので、同じ構文を以下のように書き換えることもできます。

```rust
fn fact(input:float){
  if (input>0) 1 else input * fact(input-1)
}
```

> [!NOTE]
> mimiumのシンタックスはRustを参考にしていますが、Rustのif文では条件部分の括弧が省略でき、then、else節の中括弧が必須なのに対して、mimiumでは逆に条件部分の括弧が必須で、then、else節の中括弧はブロック構文として必要なときは使い、不要なところでは省略可能です。

## include

`include("path/to/file.mmm")`という構文を用いると他のファイルをそのファイル内で読み込むことができます。

ファイルパスは絶対パスで指定された場合そのパスを、相対パスの場合、標準ライブラリ(`~/.mimium/lib`)を探してから、見つからなければそのファイルからの相対パスを検索します。

現在は読み込まれたファイルの名前空間の分割などはなく、純粋にinclude文をそのファイルのテキストに置換するだけになっています。相互依存するincludeの場合無限ループが発生することがあるので注意してください。

## BNFによる文法定義、演算子の優先順位など

TBD
