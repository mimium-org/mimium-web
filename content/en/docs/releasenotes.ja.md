---
title: Release Notes
linkTitle: Release Notes
date: 2021-01-10
weight: 50
description: |
  Update/Deprecation infos on each update
draft: false
toc_hide: false
---

## v2.0.0(2024-11-01)

mimiumはこれまでの開発でのいくつかの反省を踏まえ、0から言語を再設計することとなりました。

コンパイラ・実行環境の実装言語がC++からRustになりました。

言語の基礎となる意味論を再設計し、またそれを実行するためのVMをRust上で定義することで、表現可能な範囲が大きく広がりました。一方で、これまでのLLVMを用いたJITコンパイルではなくRust上でバイトコードインタプリタを実行するため、実行パフォーマンスは全体的に以前よりも遅くなっています。これは、今後改めてバイトコードのJITコンパイラを実装することで改善する方針で検討しています。ただ現段階の実装でも、例えばサイン波オシレーターを100本ぐらい複製する分にはパフォーマンス的に問題なく実行可能です。

新しい言語仕様の設計に伴い、たとえば以下のような信号処理を行う状態付き関数（間接的にでも`self`や`delay`を呼び出すもの）を高階関数を用いて複製するようなコードがコンパイル可能になりました。

```rust
let pi = 3.14159265359
let sr = 44100.0
fn phasor(freq){
  (self + freq/sr)%1.0
}
fn osc(freq){
  sin(phasor(freq)*pi*2.0)
}
fn amosc(freq,rate){
  osc(freq + osc(rate)*4000.0)
}
fn replicate(n,gen:()->(float,float)->float){
        let g = gen()
    if (n>0.0){
        let c = replicate(n - 1.0,gen)
        |x,rate| g(x,rate) + c(x+100.0,rate+0.1)
    }else{
        |x,rate|  0.0
    }
}
let n = 40.0
let mycounter = replicate(n,| |amosc);
fn dsp(){
    let res = mycounter(4000.0,0.5) / n
    (res,res)
}
```

### 構文の破壊的変更

#### `let`キーワードの導入

mimium v2では、いくつか表面上の言語仕様（構文）にも変更が加わっています。例えば、これまでのmimiumでは変数の宣言と破壊的代入に同じ構文を用いていました。

```rust
hoge = 10.0 // new variable declaration
hoge = 20.0 // destructive assignment
```

最も大きな構文上の仕様変更として、mimium v2ではRustと同じように、`let`キーワードを用いて変数を宣言し、`let`なしでの代入を行うことで、一度宣言した変数への破壊的代入を行います。

```rust
let hoge = 10.0
hoge = 20.0
```

これは、人によっては構文を余計に複雑にしたように思えるかもしれません。ただ、`let`キーワードによる変数の宣言は言語の意味論をより明確にすることができます。ネストされた関数定義の中では、`let`によるローカルな変数の宣言でスコープを区切ること（シャドーイング）によって、短い単純な変数名を文脈に応じて再利用することがやりやすくなります。

#### `return`キーワードの削除

mimium v0.4までは`fn`を使った関数定義では返り値の指定にreturnが必須となっていました。

```rust
fn countup(active){
    return if (active) (self+1) else 0
}
```

mimium v2以降では、単にブロック中の最後の式が返り値になります。これもRustに近い仕様ですが、mimiumでは現状loopやwhileのような構造によって要求されるearly returnの必要性がないため、そもそもreturnキーワードの存在自体が冗長なものでした。このためv2ではreturnキーワード自体を削除することにしました。

```rust
fn countup(active){
    if (active) (self+1) else 0
}
```

#### オーディオファイル読み込みの方法の変更

オーディオファイルの読み込みは、`loadwav`および`loadwavsize`で行っていましたが、これは`gen_sampler_mono`という高階関数を用いたパターンに変更になっています。

```rust
//gen_sampler_mono returns higher-order function that takes playback position in samples as an argument
let sampler = gen_sampler_mono("myfile.wav")
fn counter(){
    self+1.0
}
fn dsp(){
    counter() |> sampler
}
```

ファイルのデコードにはRustの[Symphonia](https://github.com/pdeljanov/Symphonia)クレートを使用しています。そのためmp3やFLACなど、Symphoniaで対応しているオーディオファイルは全て読み込み可能です。

### v0.4.0では実装されていたがv2.0.0では未実装の機能

- 構造体型と型エイリアスは未実装です。これは多相（ジェネリクス）の導入に関わるため今後の最優先の課題になっています。
- 配列定義と読み出しのための構文は未実装です。これは配列の内部表現（アレイかリストか）とその実装におけるメモリ解放の問題の解決のためです。

### 非破壊的な変更（追加された仕様）

#### `letrec`宣言の追加

mimiumでは、`fn`を用いた関数宣言の中でのみ再帰的関数呼び出しが許されます。インラインで関数を宣言するときは、`let myf = |x| { ... }`のようにして宣言しますが、ここでは再帰呼び出しは許されません。また`fn`を用いる関数宣言をネストすることも許されていないため、これまでネストした関数で再帰関数を書く方法がありませんでした。そこでv2では、`letrec myf = |x| { if(x>0.0) myf(x-1.0)+1.0 else 0.0 }`のような形で、インラインで再帰関数を定義できるようにしています。通常の`let`が`let (a,b) = tuple_value`のようにタプルのような複数の値を同時にバインドすることを可能にしてるのに対して、`letrec`では一つの変数名にのみバインドできることに注意してください。

#### 部分適用のためのプレースホルダー `_`

関数適用（もしくは基本の二項演算子）の引数としてアンダースコア`_`を与えると、その部分のみを新たな引数として新たな関数を作ることができます。これはシンタックスシュガー（ある種の特別扱いされたマクロ）として実装されているため、以下の2つの構文は意味的に完全に等価です。

```rust
let f = foo(1.0, _, _)
```

```rust
let f = |a1,a2| foo(1.0,a1,a2)
```

この部分適用と、パイプ演算子(`|>`)と組み合わせることでデータフローの表現をより簡潔にすることが可能になります。

```rust
fn foo(x, y, z) {
    100.0 * x + 10.0 * y + z
}
let d2 = _ / _
let f = foo(1.0, _, 3.0)
fn dsp(){
    let x = 3.0 |>
        1.0 + _ |>
        d2(_, 2.0) |>
        f

    let y = 3.0
        |> 1.0 + _
        |> |arg| d2(arg, 2.0)
        |> f

    (x, y)
}
```

現在のところ、関数の部分適用は実行時にクロージャのアロケーション/解放を伴うため僅かにパフォーマンス的なデメリットがあります。これは今後関数のインライン展開や定数畳み込みなどの簡易的な最適化で解決可能なものとなっています。



## v0.4.0(2021-04-03)

### 言語機能

構造体型と、それに伴って型エイリアス構文が導入されました。以下のサンプルのように使えます。

```rust
type stereo = (float,float)
type composite = {signal:stereo , id:float}
fn test2(){
    ogya = composite{(100,200), 100}
    ho,fu = ogya.signal
    he = ogya.id
    println(ho)
    println(fu)
    println(he)
}
test2()
```

構造体型にはまだいくつか不完全な部分もあります。

- 構造体やタプルのメンバとして関数を指定した場合は、クロージャ（引数以外の自由変数を含む関数）を代入することができません
- `hoge.a = 100`のような構造体への破壊的代入構文はパーサー部分のみ実装されていますが、コード生成部分が未実装です。

### バグ修正

- CLIへ存在しないファイルの相対パスを渡した時の挙動がおかしかったのを修正しました。(#62,by @t-sin).

### リファクタ

- 再帰バリアントなど内部的に使われているヘルパーテンプレートクラスをリファクタリングしました。


## v0.3.1(2021-02-25)

### Bugfixes

- if文がvoid型のブロックを持つときコード生成に失敗するバグを修正
- `==`と`!=`演算子が実装されていなかったのを修正

### Refactoring

- `Runtime`クラスから実際にJITコンパイルやGlobalコンテキストを実行する部分を`ExecutionEngine`クラスとして切り出しました。これは後々インタプリタバックエンドを作るときや、環境変数機能を実装することを見越した変更です。

### New Function

パッチリリースではあるものの、新しい関数も追加されています。

- 1サンプルだけディレイする`mem`関数が追加されました。これを利用することでbiquadフィルタが現実的に実装しやすくなります。`mimium-core/filter.mmm`にサンプルコードを追加しました。

### Other updates

全コントリビューターを[all-contributors](https://allcontributors.org/)を用いてReadme.mdに表示するようにしました。

## v0.3.0 (2021-02-03)

### 新しい言語機能

#### タプルと配列型

aggregate typeとしてタプル、配列が追加されました。

タプル型は括弧とカンマで構築できるようになりました。
現在のところ、タプル型の値を取得するには、C++のstructual bindingのような方法しかありません。
```rust
# タプル構造
triples = (100,200,300)//型シグネチャは (float,float,float)

one,two,three = triples
```
将来的には `triples.0` のようなドットアクセス演算子が追加される予定です。

配列型は角括弧とカンマで構築することができます。
現在のところ、すべての配列は mutable , fixed size で、llvm モジュールの中で private global variable として宣言されています。
ユニークな機能として、オーディオファイルの読み込みと同様に、フローティングポインタインデックスによる補間がサポートされています。

```rust
# Array Construction
myarr = [100,200,300]
internalv = myarr[0]//zero-based index
myarr[2] = 400//the array is now [100,200,400]
interp = myarr[0.5]//the result will be 150(linear interpolation)
```

#### dsp機能のマルチチャンネル対応

ステレオ出力/チャンネルをサポートしました。。

入出力の数は `dsp` 関数の型によって決まります。
例えば、ステレオパンナーのコード以下のように書くことができます。

```rust
fn panner(input:float,pan:float) -> (float,float){
    return (input*pan,input*(1-pan))
}

fn dsp(input:(float,float))->(float,float){
    src = random()*0.2
    res = panner(src,sin(5*now/48000)+1*0.5)
    return res
}
```
これは以下の点で破壊的変更になります。

1. v0.2以前は `dsp` の入力パラメータが `time` であったこと (これは `now` が実装される前の一時的な解決策でした)、
2. 出力型が `float` であったが、現在は `dsp` の型は `(float のタプル)->(float のタプル)` とすべきであること、つまり、モノラル処理をしたい場合でも、1つの変数を float のタプルで受け取り、float のタプルを返す関数であること、ということです。

この言語仕様に合わせて、いくつかのexampleを書き換えました。

### C++ライブラリとしてのmimium

ライブラリヘッダとfrontend(アプリケーションインスタンスとCLI)の依存関係を整理しました。
C++ライブラリとしてmimiumが使えるようになりました。CMakeを使えば簡単にインポートできます。

最低限の例は https://github.com/mimium-org/mimium-libimport-example にあります。

### その他の変更点

- LLVMのサポートバージョンが11になりました。
- Code_Of_Conduct.mdを追加しました。

## v0.2.0 (2020-12-24)

### 改善点

- Windowsビルド(MSYS2上)の準備ができました。ビルドしたい場合はGitHub Actionsのワークフローを確認してください。
- プリミティブ関数delay(input,delaytime)`を追加しました。
  - 最大遅延時間は現在44100サンプルに固定されています。
- (実験的な)シンプルなマクロプリプロセッサが追加されました。
  - グローバルコンテキストに `include "otherfile.mmm`と書くことで、他のソースファイルをインクルードできるようになりました。
- 中間レベルの内部表現をリファクタリングしました。

## v0.1.5 (2020-09-28)

### バグを修正しました。

- if文の中にfcallが1つしか入っていない場合のコンパイルエラーを修正した(Thanks @t-sin)。

### 改善点

- GitHub Actionsで、Changelogをリリースの中に自動的にふむめるようにしました。

### その他

現在、v0.2.0に含まれる予定の遅延プリミティブ関数などの新機能を開発中です。

## v0.1.4 (2020-09-11)

### バグを修正しました。

- clangとlibstdc++の組み合わせでのコンパイルエラーを修正した。
- 関数内で if を式として返すとクラッシュする問題を修正した。

## 改善点

- 開発環境でのアドレスサニタイザと簡易ファジングテストを導入しました。
- ランタイムのデストラクタ呼び出し時にユーザコードのメモリ確保が解放されるようにした。
    - 以前のバージョンでは、ユーザコードによるヒープ確保は解放されていなかったが、ランタイムのデストラクタが呼ばれるとプログラム自体が終了するので、大きな問題ではない。この改善は、同じプロセスで何度もコンパイルを繰り返すようなファジングテストでは、主に意味があります。

## v0.1.3 (2020-09-09)

### バグを修正しました。

- linuxでifステートメントを使用した場合の異常なクラッシュを修正 
- 式として使用される場合のif文の演算子の優先順位を修正

```rust
// 数学演算子は if や else よりも優先度が高いです!
myvar = if(cond) 100+20 else 200*50
```

## v0.1.2 (2020-09-07)

### バグを修正しました。

- 以前のリリースでは、if文のためのllvm生成が含まれていませんでした。if文/式が正しく動作するようになった。
- 改行で終わるコメントアウトが正しく解析されないバグを修正した。

### リファクタリング

MIR(Mid-Level Representation)関連のクラスの実装を簡素化しました。
v0.1.0でリファインされた ast クラスと同様に、データはメンバ関数を持たず、集約初期化で初期化されます。

## v0.1.1 (2020-09-05)

### バグを修正しました。

このリリースでは、主にパーサの修正を行いました。

括弧内の**block**文の仕様はRustと同様です。

ブロック内の文の最後の行に単一の式を入れたり、`return`文を入れたりすると、ブロックは関数呼び出しやインフィックス操作のように、単なる**式**として扱うことができます。その値はブロックの値そのものになります。

したがって、以下の例はすべて有効です。

```rust
fn test(x,y){
    localvar = x*y+100
    localvar //last line is expression.
}
fn test(x,y){
    localvar = x*y+100
    return localvar //last line is return statement.
}

testvar = { velylocal = 100
            verylocal*2004} * 300 // this is also valid...
```

この変更により、`if` 文は式と文の両方を扱えるようにな離ました。then/else文の内容が戻り値を持たない場合は、`void`型の関数と同じように扱われます。


## v0.1.0 (2020-08-21)

今回のリリースは内部処理のリファクタリングが中心で、特に AST(Abstract Syntax Tree)関連のクラスは開発初期に書かれたもので、MIRやType関連のような新しく導入されたクラスとは全く異なる実装スタイルとなっています。今回のコンパイラ開発では、クラス継承ではなく、`std::variant`を使った方法に動的多相性を統一しています。

今回のリリースでは、新機能の追加や変更点はありませんが、多くの不安定性、特に型推論の誤りを修正しました。

また、Ubuntu上でのビルドも準備しています。依存関係は[github アクションワークフローページ](https://github.com/mimium-org/mimium/actions/runs/217956579/workflow)から確認できます。Windowsでテストできる方を募集しています。

## v0.0.0 (2020-02-15)

最初のリリースです！配列、構造体、インクルード/モジュールはありません。これは mimium の「概念実証」バージョンです。

### 既知のバグ

- self` を使用する同じ関数を2回以上呼び出すと、selfのインスタンス化が正しく行われない。(関数のエイリアスを定義することでこの挙動を回避できます)
- 関数の中では、少なくとも1つのグローバル変数を使用しなければなりません。

### 制限事項

- if` は複数の文ではなく式のみを持つことができます(他の言語でいうところの条件演算子(`(cond)? then_expr : else_expr`)のようなものです)。
- 配列アクセス `[]` は，loadwav(path)` を用いて読み込んだオーディオファイルに対してのみ利用できるようにした。配列アクセスには境界チェックはありません。配列のサイズは `loadwavsize(path)` で取得できます。