---
title: Grammar Definition
date: 2021-01-16T10:57:29.018Z
weight: 1
description: This page is about the definition of mimium grammer.
draft: false
toc_hide: false
---
This page is about the rule of mimium grammer.

## Comment out

As in C++ and JavaScript, anything to the right of `//` in a line is treated as a comment.
You can also comment out multiple lines at once by enclosing them as `/* */`.

## Variable declaration and assignment

In mimium, when a value is assigned with the `=` operator, a new variable is created if the variable with the specified name does not exist yet.
There is no need to use keywords such as ``let'' when declaring variables.

``rust
mynumber = 1000
The variables are all modifiable (mutable).

All variables are mutable. All variables are mutable, i.e., you can assign new values to variables that have already been declared.

```rust
mynumber = 1000 // variable is declared, and 1000 is assigned
mynumber = 2000 // 2000 is newly assigned to mynumber
````

## type

**Type** is a concept to distinguish between variables and other data, such as numbers and strings, depending on their purpose.
mimium is a **statically typed** language, which means that all types are determined at compile time (before the actual sound is made).

Statically typed languages generally have an advantage in terms of execution speed over languages that check types during execution. On the other hand, there is a disadvantage of manual type specification, which tends to lead to long descriptions. mimium has a feature called **Type Inference**, which allows you to omit type annotations if the type can be automatically determined from the context, thus keeping your code concise.

There are two types: primitive types, which are the smallest unit that cannot be further decomposed, and aggregate types, which are made by combining multiple types.

Explicit annotation of types is possible at the time of variable declaration and function declaration.
In the parameters of variables and functions, the type can be specified by writing the name of the type followed by a `:` (colon).

```rust
myvar:float = 100
```
Assigning to a different type will result in a compile-time error, as shown below.
```rust
myvar:string = 100
````

In function type declarations, the return value can be specified by following the parameter parentheses with a ``->`` between them.

```rust
fn add(x:float,y:float)->float{
  return x + y
}
```.
In the case of this add function, we can predict that x and y are floats from the context [^binaryop], so we can omit it as follows.

```rust
fn add(x,y){
  return x+y
}
```

[^binaryop]: Because mimium can only use arithmetic operators such as `+` and `*` for numeric types. This may change in the future.

### Primitive types

The only primitive types in mimium are `float`, `string` and `void`.

The only numeric type in mimium is `float` (internally a 64bit float).
Integers can be used with the `round`, `ceil`, and `floor` functions.

Values of type `string` can be generated from double-quoted string literals, such as `"hoge"`.
Currently, it does not support string cutting or merging, and its usage is basically the same as

1. pass it to the `printstr` function for debugging purposes. 2.
2. pass it to the `loadwav` function to load an audio file. 3. pass it to `include` to include it.
3. pass it to `include` to load other source files.

3. pass to `include` to load other source files.

The `void` type has no value and is used to indicate that there is no return value for the function.

### Composite types

#### Arrays

An array is a type that can store multiple values of the same type in succession. It can be generated by comma-separated values enclosed in `[]` (angle brackets).

```rust
myarr = [1,2,3,4,5,6,7,8,9,10]
```

You can retrieve the value of an array type by specifying a zero-based index with angle brackets, such as `myarr[0]`.

```rust
arr_content = myarr[0] //arr_content should be 1
```
You can also rewrite the contents of the array by using angle brackets on the left side value as well.

```rust
myarr[4] = 20 //myarr becomes [1,2,3,4,20,6,7,8,9,10].
````

**The size of the array is fixed. The size of the array is fixed, so you can't add values to the back of the array. There is no bounds check, so out-of-range access will cause a crash. ** The size of the array is fixed.
##### Automatic interpolation

Indexes are automatically linearly interpolated when accessed with decimal values.

```rust
arr_content = myarr[1.5] //should be 2.5
```
There is no automatic rounding to integers, so if you want to avoid interpolation, you need to round the indices using the `round` function or something similar.

#### Tuples

A tuple is a value that combines different types into one. They can be generated by enclosing variables in `()` (round brackets) and inserting comma-separated variables.
Tuples are also similar to arrays, but each element can have a different type.

```rust
mytup = (100,200,300)
```

You can retrieve the value of a tuple by placing a comma-separated variable at the left-hand side value. There is no need to separate them with parentheses in this case.

```rust
one,two,three = mytup
```

{{< alert color="warning">}}
*In the future, we will implement a notation to extract by index, like `mytup.1`, instead of just decomposing by left side value.*
{{< /alert >}}

Tuples are typically used in mimium to group together channels of audio signals such as stereo and multi-channel in signal processing.

## Functions

A function is a collection of reusable procedures that take multiple values and return a new value.

As an example, consider the add function, which just adds two values together and returns them.

To store it as a variable with an explicit type in mimium, write the following

```rust
fn add(x,y){
  return x+y
}
```

In mimium, functions can be treated as first-class values. This means that you can assign a function to a variable or take it as a parameter of a function.

For example, the type annotation of the previous add function is `(float,float)->float`. To assign the previous add function to a variable, you can write the following If you want to assign the function as a function parameter, see the section on higher-order functions.

```rust
my_function:(float,float)->float = add
```
### Anonymous functions (lambda expressions)

The previous function declaration is actually an alias to the syntax for storing anonymous functions in variables, as shown below.

```rust
add = |x:float,y:float|->float{return x+y} 
```
It is also possible to call such a function directly without assigning it to a variable.

```rust
println(|x,y|{return x + y}(1,2)) //print "3"
```
Also, as will be explained in the block syntax section, the last line of the block can be substituted for return by simply placing an expression in place of return. In other words, the `add` function, combined with type inference, can be omitted until the following example.

```rust
add = |x,y|{x+y}
```

### Pipe (`|>`) operators

In mimium, you can use the pipe operator `|>` to rewrite nested function calls like `a(b(c(d)))` as `d |> c |> b |> a`.

{{< alert color="warning">}}
*Currently, the pipe operator can only be used with functions that have a single parameter. It will be possible to use it in functions with more than one parameter by automatically expanding the tuple type value with a feature such as the parameter pack.*
{{< /alert >}}

### Looping by recursion

Named functions can also call themselves.

The fact function to compute the factorial can be defined as follows

```rust
fn fact(input:float){
  if(input>0){
    return 1
  }else{
    return input * fact(input-1)
  }
}
```

Use recursive functions with care, as they can cause infinite loops.
### self

In a function, you can use a special keyword called `self`.
`self` is a variable that can refer to the last value returned by a function. For example, the following function will return a value that increases by `increment` each time it is called.

```rust
fn counter(increment){
  return self+increment
}
```

Self is basically only available for functions that originate from the `dsp` function. self is initialized to 0 when the audio engine is started, and a separate value is created and managed for each calling context.
For example, in the following example, the `counter` function is given a different increment for each of its functions, which internally allocates two pieces of memory for self, with lch increasing by 0.01 samples every time it crosses 1 and resetting to 0, and rch increasing by 0.05 samples every time it crosses 1.

```rust
fn dsp()->(float,float){
  lch = counter(0.01)%1
  rch = counter(0.05)%1
  return (lch,rch)
}
```

{{< alert color="warning">}}
Self is currently always initialized with 0. We are currently working on a way to change this initial value.
{{< /alert >}}


### Scope of variables

mimium is a lexical-scoped language, which means that it is possible to refer to variables defined outside of a function.

TBD.

### Expressions, statements, and blocks

A collection of **statements** enclosed in curly braces `{}` used in a function, etc. is a unit called a **block**.
A **statement** almost always consists of a syntax for assigning **expressions**, such as `a = b`.
**expression** is a unit consisting of numbers like `1000`, variable symbols like `mynumber`, arithmetic expressions like `1+2*3`, and function calls with return values like `add(x,y)`.

**Block** is actually one of the **expressions**.
You can put multiple statements in a block, and the last line can use `return` to specify the value to be returned. The `return` keyword in the last line can also be omitted and just putting expression is allowed.

For example, the following syntax is grammatically correct. (*As of v0.3.0, this syntax is implemented incorrectly and does not work. *)

```rust
//mynumber should be 6
mynumber = {
  x = 2
  y = 4
  return x+y
}
```

## Conditional

Conditional in mimium has the syntax `if (condition) then_expression else else_expression`.
`condition`, `then_expression`, and `else_expression` are all expressions.
If the value of `condition` is greater than zero, the `then_expression` part is evaluated, otherwise the `else_expression` is evaluated.

If the then/else part is expressed as a block, it can be written in a C-like way as follows.

```rust
fn fact(input:float){
  if(input>0){
    return 1
  }else{
    return input * fact(input-1)
  }
}
```
On the other hand, the if statement itself can be treated as an expression, so the same syntax can be rewritten as follows.
Note that the parentheses in the conditional part cannot be omitted.

```rust
fn fact(input:float){
  return if (input>0) 1 else input * fact(input-1)
}
```
## Deferred execution with `@` operator

You can defer the execution of a function by following the function call with `@` followed by a value of numeric type.
The unit of time is samples.

For example, the following example writes 100 and 200 to the standard output at the 0th and 48000th samples after starting the audio driver.

```rust
println(100)@0
println(200)@48000
```

Currently, the `@` operator can only be used for functions of type `void` (which have no return value).

By delaying the execution of a recursive function with `@`, it is also possible to repeat certain operations at regular intervals.
For example, the following example will increment the number from 0 to 1 at 48000 sample intervals and write it to the standard output.

```rust
fn loopprint(input)->void{
  println(input)
  loopprint(input+1)@(now+48000)
}
loopprint(0)@0
```

## include

The syntax `include("path/to/file.mmm")` allows you to include other files in the file.

The file path can be an absolute path or a path relative to the file.
Currently, there is no namespace division, and the include statement is purely replaced by the text of the file (but once a file is loaded, it will not be loaded more than once).

## Syntax definition by BNF, operator precedence, etc.

TBD
